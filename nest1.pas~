unit nest1;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  ExtCtrls, ComCtrls, StdCtrls, Clipbrd, RXShell;

type
  TForm1 = class(TForm)
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    GroupBox1: TGroupBox;
    Label3: TLabel;
    RGtype: TRadioGroup;
    ListBox1: TListBox;
    Bloadbuff: TButton;
    Bneib: TButton;
    Button2: TButton;
    ComboBox1: TComboBox;
    GroupBox2: TGroupBox;
    Img: TImage;
    Label1: TLabel;
    TB1: TTrackBar;
    UpDown1: TUpDown;
    Button1: TButton;
    Panel1: TPanel;
    ListBox2: TListBox;
    Image1: TImage;
    StatusBar1: TStatusBar;
    Button3: TButton;
    Button4: TButton;
    TabSheet3: TTabSheet;
    GroupBox4: TGroupBox;
    LB3: TListBox;
    Image2: TImage;
    Button6: TButton;
    TrackBar2: TTrackBar;
    GroupBox5: TGroupBox;
    TrackBar3: TTrackBar;
    Label2: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure BloadbuffClick(Sender: TObject);
    procedure TB1Change(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure UpDown1Click(Sender: TObject; Button: TUDBtnType);
    procedure Button1Click(Sender: TObject);
    procedure BneibClick(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure Button6Click(Sender: TObject);
    procedure TrackBar2Change(Sender: TObject);
    procedure TrackBar3Change(Sender: TObject);
    procedure Image2MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Image2MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Image2MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure RxTrayIcon1Click(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

type nestpoint = record
       N:integer;
       Number:integer;
       Date:integer;
       X,Y:Real;
       Rast:array[1..100] of real;
       Delta_Rast:array[1..100] of real;
       Next:pointer;
       Attempted:Boolean;
       R_av:real;
     end;

type dot = record
       N:integer;
       R:real;
     end;

var
  Form1: TForm1;
  clb:TClipboard;
  First_p:^nestpoint;
  mash:real;
  i0,j0:integer;
  i1,j1,i2,j2:integer;
  moved:Boolean;
  x0,y0:integer;

implementation

{$R *.DFM}

function StringLen(s:string):integer;
Var
  i:integer;
begin
 i:=1;
 if s<>'' then
     begin
       while s[i]<>#0 do
         i:=i+1;
     end
  else i:=0;
 StringLen:=i;
end;//StringLen

procedure  DelComma(var s:string);
var
 i:integer;
begin
 for i:=1 to StringLen(s) do
   if s[i]=',' then s[i]:='.';
end;// DelComma(s);

procedure  UnDot(var s:string);
var
 i:integer;
begin
 for i:=1 to StringLen(s) do
   if s[i]='.' then s[i]:=',';
end;// UnDot(s);

procedure AddDot(x,y:real; N,date,number:integer);
var
 temp_p,new_p:^nestpoint;
 P:Pointer;
 i:integer;
begin
 if first_p=NIL then
                    begin
                      New(first_p);
                      first_p^.X:=x;
                      first_p^.Y:=y;
                      first_p^.date:=date;
                      first_p^.N:=n;
                      first_p^.number:=number;
                      for i:=1 to 100 do first_p^.Rast[i]:=-1;
                      for i:=1 to 100 do first_p^.Delta_Rast[i]:=-1;
                      first_p^.Attempted:=False;
                      first_p^.Next:=nil;
                    end
     else
                    begin
                      p:=first_p;
                      temp_p:=p;
                      while temp_p^.Next<>nil do
                        begin
                          temp_p:=temp_p^.Next;
                        end;//while
                      New(new_p);
                      new_p^.X:=x;
                      new_p^.Y:=y;
                      new_p^.date:=date;
                      new_p^.N:=n;
                      new_p^.Number:=number;
                      for i:=1 to 100 do new_p^.Rast[i]:=-1;
                      for i:=1 to 100 do new_p^.Delta_Rast[i]:=-1;
                      new_p^.Attempted:=False;
                      new_p^.next:=nil;
                      temp_p^.Next:=new_p;
                    end;//if

end;//AddDot()

procedure  ClearMemory;
Var p:pointer;
    temp_p,temp1_p:^nestpoint;
    pred_p:^nestpoint;
begin
 p:=first_p;
 temp_p:=p;
 while temp_p<>nil do
   begin
     temp1_p:=temp_p;
     pred_p:=nil;
     while temp1_p^.Next<>nil do
       begin
         p:=temp1_p;
         pred_p:=p;
         temp1_p:=temp1_p^.Next;
       end;//while
     if Pred_p<>nil then pred_p^.next:=nil;
     if temp1_p^.N=first_p^.n then
                               begin
                                first_p:=nil;
                                temp_p:=nil;
                               end;
     Dispose(temp1_p);
   end;//while
end;//ClearMemory;

function CountPoints:integer;
var
 res:integer;
 temp_p:^nestpoint;
 p:pointer;
begin
 p:=first_p;
 temp_p:=p;
 res:=0;
 while temp_p<>nil do
   begin
     res:=res+1;
     temp_p:=temp_p^.Next;
   end;//while
 CountPoints:=Res;
end;

procedure  Calc;
var
    temp_p,temp1_p:^nestpoint;
    p:pointer;
    rast:real;
    i:integer;
    s:string;
    L:Tlist;
    temp_d,temp1_d:^dot;
    changed:Boolean;
begin
{    p:=first_p;
    temp_p:=p;
    while temp_p<>nil do
      begin
        r:=0;
        i:=1;
        while r<400 do
        begin
          p:=first_p;
          temp1_p:=p;
          while temp1_p<>nil do
            begin
              rast:=sqrt(sqr(temp_p^.x-temp1_p^.x)+sqr(temp_p^.y-temp1_p^.y));
              if (temp_p^.n<>temp1_p^.N) and (rast<(r+0.00005*Form1.TrackBar1.Position)) and (rast>(r-0.00005*Form1.TrackBar1.Position)) then begin
                                                             temp_p^.Rast[i]:=rast;
                                                             i:=i+1;
                                                             break;
                                                           end;//if
              temp1_p:=temp1_p^.Next;
            end;//while
          r:=r+0.0001*Form1.TrackBar1.Position;
        end;//while r
        //val(s,temp_p^.N,code);
        str(temp_p^.N,s);  //
        form1.StatusBar1.SimpleText:='Загрузка данных. Гнездо #'+s;
        temp_p:=temp_p^.Next;
      end;//while}

    L:=Tlist.Create;

    p:=first_p;
    temp_p:=p;
    while temp_p<>nil do//главный цикл
      begin
          //заполняем список
          p:=first_p;
          temp1_p:=p;
          while temp1_p<>nil do
            begin
              if (temp_p^.n<>temp1_p^.N)  then begin
                                               rast:=sqrt(sqr(temp_p^.x-temp1_p^.x)+sqr(temp_p^.y-temp1_p^.y));
                                               new(temp_d);
                                               temp_d^.N:=temp1_p^.N;
                                               temp_d^.R:=rast;
                                               L.Add(temp_d);
                                               temp_d:=nil;
                                            end;//if
              temp1_p:=temp1_p^.Next;
            end;//while
        //cортировка
        changed:=true;
        while changed do
          begin
            changed:=false;
            for i:=0 to (L.Count-2) do
              begin
                temp_d:=L.Items[i];
                temp1_d:=L.Items[i+1];
                if temp1_d^.R<temp_d^.R then
                      begin
                         L.Exchange(i,i+1);
                         Changed:=True;
                      end;
              end;//for
          end;//while
        //закидываем всё в Rast[]
        for i:=0 to (L.Count-1) do
          begin
            temp_d:=L.Items[i];
            temp_p^.Rast[i+1]:=temp_d^.R;
          end;
        str(temp_p^.N,s);  //
        form1.StatusBar1.SimpleText:='Загрузка данных. Гнездо #'+s;
        L.Clear;
        temp_p:=temp_p^.Next;
      end;//while

end;// Calc;

procedure  CalcAv;//вычисление среднего расстояния до ближайших соседей
var
    temp_p:^nestpoint;
    p:pointer;
    i,i_max:integer;
    max:real;
    s,s_buf,s1,s2,s3:string;
    r:real;
    pch_buf:PChar;
begin
    Form1.LB3.Clear;
    p:=first_p;
    temp_p:=p;
    while temp_p<>nil do
      begin
        if temp_p^.Attempted then//если не пидорок
          begin
            max:=0;
            i_max:=1;
            for i:=1 to 6 do
              if (temp_p^.Delta_Rast[i] > 0) and (temp_p^.Delta_Rast[i] > max) then
                begin
                  max:=temp_p^.Delta_Rast[i];
                  i_max:=i;
                end;//if
            r:=0;
            for i:=1 to i_max do
              r:=r+temp_p^.rast[i];
            r:=r/i_max;
            temp_p^.R_av:=r;
            str(temp_p^.N,s);
            str(r:2:4,s1);
            str(i_max,s2);
            if Form1.RGtype.ItemIndex=1 then
              begin
                str(temp_p^.Number,s3);
                s_buf:=s_buf+s3+#9+s1+#9+s2+#13+#10;
              end
            else
              s_buf:=s_buf+s1+#9+s2+#13+#10;
            Form1.LB3.Items.Add('№'+s+': '+s1+' - соседей:'+s2);
          end//if
        else
          begin
            if Form1.RGtype.ItemIndex=1 then
              begin
                str(temp_p^.Number,s3);
                s_buf:=s_buf+s3+#9+'NAN'+#9+'0'+#13+#10;
              end
            else
               s_buf:=s_buf+'NAN'+#9+'0'+#13+#10;
            str(temp_p^.N,s);
            Form1.LB3.Items.Add('№'+s+': нет соседей.');
          end;//else
        temp_p:=temp_p^.Next;
      end;//while
  //запихиваем в буфер
  UnDot(s_buf);
  Clb.Open;
  GetMem(pch_buf,stringLen(s_buf)+1);
  for i:=1 to stringLen(s_buf) do
    pch_buf[i-1]:=s_buf[i];
  pch_buf[i]:=#0;
  Clb.SetTextBuf(pch_buf);
  Clb.Close;
  Form1.Label2.Caption:='Результат в буфере.';

end;// CalcAv;

procedure  DeltaCalc;
var
    temp_p:^nestpoint;
    p:pointer;
    max:real;
    i:integer;
begin
    p:=first_p;
    temp_p:=p;
    while temp_p<>nil do
      begin
        //вычисление дельты
        i:=1;
        for i:=1 to 10 do
          begin
            temp_p^.Delta_Rast[i]:=temp_p^.Rast[i+1]-temp_p^.Rast[i];
          end;
        temp_p^.Delta_Rast[i]:=-1;
        //поиск максимальной
        max:=0;
        for i:=1 to 9 do
          begin
            if (temp_p^.Delta_Rast[i]>max)and (temp_p^.Delta_Rast[i]>0) then
                         max:=temp_p^.Delta_Rast[i];
          end;
        //нормализация
        for i:=1 to 9 do
          begin
            temp_p^.Delta_Rast[i]:=temp_p^.Delta_Rast[i]/max;
          end;
        temp_p:=temp_p^.Next;
      end;//while
end;// DeltaCalc;

procedure  DrawResults(m:real);
var
  N,i:integer;
  pos:integer;
  temp_p:^nestpoint;
  p:pointer;
  X,Y,X_old,Y_old:integer;
  s,s1:string;
  t,max:real;
begin
 N:=CountPoints;
 with form1 do
begin
 TB1.Max:=N;
 TB1.Min:=1;
 pos:= TB1.position;
 Img.Canvas.Brush.Color:=clWhite;
 Img.Canvas.Rectangle(0,0,Img.Width,Img.Height);
 p:=first_p;
 temp_p:=p;
 i:=1;
 str(pos,s);
 str(N,s1);
 Img.Canvas.Pen.Color:=clBlue;
 Img.Canvas.TextOut(15,1,'Nest #: '+s+' from '+s1+'.');
 Img.Canvas.MoveTo(10,10);
 Img.Canvas.LineTo(10,Img.Height-10);
 Img.Canvas.MoveTo(10,10);
 Img.Canvas.LineTo(7,13);
 Img.Canvas.MoveTo(10,10);
 Img.Canvas.LineTo(13,13);

 Img.Canvas.MoveTo(10,Img.Height-10);
 Img.Canvas.LineTo(Img.Width-10,Img.Height-10);
 Img.Canvas.LineTo(Img.Width-13,Img.Height-13);
 Img.Canvas.MoveTo(Img.Width-10,Img.Height-10);
 Img.Canvas.LineTo(Img.Width-13,Img.Height-7);

 Img.Canvas.TextOut(Img.Width-10,Img.Height-25,'N');
 Img.Canvas.TextOut(2,10,'L');

 i:=1;
 while true do       //poisk nuzhnogo e'lementa
   begin
     if i=pos then break;
     i:=i+1;
     temp_p:=temp_p^.Next;
   end;
if m<0 then begin    //m<0 -самому искать масштаб
                  max:=0;
                  for i:=1 to (N-1) do      //najti max
                    if temp_p^.Rast[i]>max then max:=temp_p^.Rast[i];
               end
        else   begin
                  max:=0;
                  for i:=1 to (N-1) do      //najti max
                    if temp_p^.Rast[i]>max then max:=temp_p^.Rast[i];
                  max:=max*m;
               end;
 //riski
   Img.Canvas.Pen.Color:=clBlack;
 for i:=1 to round((Img.Height-20)/max)  do
   begin
    y:=Img.Height-round(i*(Img.Height-20)/max)-10;
    Img.Canvas.MoveTo(10,y);
    Img.Canvas.LineTo(13,y);
   end;
 for i:=1 to N-1  do
   begin
    x:=i*((Img.Width-20) div (n))+10;
    Img.Canvas.MoveTo(x,Img.Height-10);
    Img.Canvas.LineTo(x,Img.Height-13);
   end;

 //vyvod Rast
   x_old:=10;
   y_old:=Img.Height-10;
   Img.Canvas.Pen.Color:=clGreen;
 for i:=1 to (N-1) do
   begin
    x:=i*((Img.Width-20) div (n))+10;
    t:=temp_p^.Rast[i]*(Img.Height-20)/max;
    y:=Img.Height-round(t)-10;
    Img.Canvas.Pen.Color:=clGreen;
    Img.Canvas.MoveTo(x_old,y_old);
    Img.Canvas.LineTo(x,y);
    Img.Canvas.Pen.Color:=clBlack;
    Img.Canvas.Rectangle(x-1,y-1,x+1,y+1);
    x_old:=x;
    y_old:=y;
   end;

 //vyvod DeltaRast
   x_old:=10;
   y_old:=Img.Height-10;
   Img.Canvas.Pen.Color:=clRed;
 for i:=1 to (9) do
   begin
    x:=i*((Img.Width-20) div (n))+10;
    t:=temp_p^.Delta_Rast[i]*(Img.Height-20)/max;
    y:=Img.Height-round(t)-10;
    Img.Canvas.Pen.Color:=clRed;
    Img.Canvas.MoveTo(x_old,y_old);
    Img.Canvas.LineTo(x,y);
    Img.Canvas.Pen.Color:=clBlack;
    Img.Canvas.Rectangle(x-1,y-1,x+1,y+1);
    x_old:=x;
    y_old:=y;
   end;
end;//with
end;// DrawResults;

procedure DrawMapR(K:real);
var
 p1:^nestpoint;
 t:pointer;
 s1:string;
 mash:real;
 max_x,min_x:real;
 max_y,min_y:real;
 cx,cy:real;
begin
with Form1 do
begin
 //очистка
 Image1.Canvas.Brush.Color:=clWhite;
 Image1.Canvas.Rectangle(0,0,Image1.Width,Image1.Height);
 //выбор масштаба
 t:=first_p;
 p1:=t;
 max_x:=0;
 max_y:=0;
 while p1 <> nil do
   begin
     if p1^.y>max_y then max_y:=p1^.y;
     if p1^.y>max_x then max_x:=p1^.x;
     p1:=p1^.Next;
   end;
 t:=first_p;
 p1:=t;
 min_x:=max_x;
 min_y:=max_y;
 while p1 <> nil do
   begin
     if p1^.Y<min_y then min_y:=p1^.Y;
     if p1^.Y<min_x then min_x:=p1^.x;
     p1:=p1^.Next;
   end;
 if k<0 then
        mash:=(Image1.Width)/(-min_y+max_y)
   else mash:=K*(Image1.Width)/(-min_y+max_y);
 cx:=(max_x+min_x)/2;
 cy:=(max_y+min_y)/2;
      //вывод
 t:=first_p;
 p1:=t;
 while p1 <> nil do
   begin
     str(p1^.N,s1);
     Image1.Canvas.Brush.Color:=clWhite;
     Image1.Canvas.Brush.Style:=bsClear;
     if not(p1^.Attempted) then
                   begin
                     Image1.Canvas.Pen.Color:=clRed;
                     Image1.Canvas.Rectangle(Image1.width div 2 + round((p1^.x-cx)*mash)-1,Image1.height div 2 - round((p1^.y-cy)*mash)-1,Image1.width div 2 + round((p1^.x-cx)*mash)+1,Image1.height div 2 - round((p1^.y-cy)*mash)+1);
                     Image1.Canvas.Font.Color:=clRed;
                     Image1.Canvas.TextOut(Image1.width div 2 + round((p1^.x-cx)*mash),Image1.height div 2 - round((p1^.y-cy)*mash),s1);
                   end
              else begin
                     Image1.Canvas.pen.Color:=clGreen;
                     Image1.Canvas.Rectangle(Image1.width div 2 + round((p1^.x-cx)*mash)-1,Image1.height div 2 - round((p1^.y-cy)*mash)-1,Image1.width div 2 + round((p1^.x-cx)*mash)+1,Image1.height div 2 - round((p1^.y-cy)*mash)+1);
                     Image1.Canvas.Font.Color:=clGreen;
                     Image1.Canvas.TextOut(Image1.width div 2 + round((p1^.x-cx)*mash),Image1.height div 2 - round((p1^.y-cy)*mash),s1);
                   end;
      p1:=p1^.Next;
   end;//while
end;//with
end;

procedure DrawMap(K:real; cx_m,cy_m:integer);
var
 p1:^nestpoint;
 t:pointer;
 s1:string;
 mash:real;
 max_x,min_x:real;
 max_y,min_y:real;
 cx,cy:real;
begin
with Form1.Image2 do
begin
 //очистка
 Canvas.Brush.Color:=clWhite;
 Canvas.Rectangle(0,0,Width,Height);
 //выбор масштаба
 t:=first_p;
 p1:=t;
 max_x:=0;
 max_y:=0;
 while p1 <> nil do
   begin
     if p1^.y>max_y then max_y:=p1^.y;
     if p1^.y>max_x then max_x:=p1^.x;
     p1:=p1^.Next;
   end;
 t:=first_p;
 p1:=t;
 min_x:=max_x;
 min_y:=max_y;
 while p1 <> nil do
   begin
     if p1^.Y<min_y then min_y:=p1^.Y;
     if p1^.Y<min_x then min_x:=p1^.x;
     p1:=p1^.Next;
   end;
 if k<0 then
        mash:=(Height)/(-min_y+max_y)
   else mash:=K*(Height)/(-min_y+max_y);

 cx:=(max_x+min_x)/2;
 cy:=(max_y+min_y)/2;
{ if (cx_m>=0) and (cy_m>=0) then
   begin
     cx:=(cx_m-width/2)/mash+cx;
     cy:=-(cy_m-height/2)/mash+cy;
     x0:=cx_m;
     y0:=cy_m;
   end; }
      //вывод
 t:=first_p;
 p1:=t;
 while p1 <> nil do
   begin
     str(p1^.N,s1);
     Canvas.Brush.Color:=clWhite;
     Canvas.Brush.Style:=bsClear;
     if not(p1^.Attempted) then
                   begin
                     Canvas.Pen.Color:=clRed;
                     Canvas.Rectangle(cx_m + round((p1^.x-cx)*mash)-1,cy_m - round((p1^.y-cy)*mash)-1,cx_m + round((p1^.x-cx)*mash)+1,cy_m - round((p1^.y-cy)*mash)+1);
                     Canvas.Font.Color:=clRed;
                     Canvas.TextOut(cx_m + round((p1^.x-cx)*mash),cy_m - round((p1^.y-cy)*mash),s1);
                   end
              else begin
                     Canvas.pen.Color:=clGreen;
                     Canvas.Rectangle(cx_m + round((p1^.x-cx)*mash)-1,cy_m - round((p1^.y-cy)*mash)-1,cx_m + round((p1^.x-cx)*mash)+1,cy_m - round((p1^.y-cy)*mash)+1);
                     Canvas.Ellipse(cx_m + round((p1^.x-p1^.R_av-cx)*mash),cy_m - round((p1^.y+p1^.R_av-cy)*mash),cx_m + round((p1^.x+p1^.R_av-cx)*mash),cy_m - round((p1^.y-p1^.R_av-cy)*mash));                     Canvas.Font.Color:=clGreen;
                     Canvas.Font.Color:=clGreen;
                     Canvas.TextOut(cx_m + round((p1^.x-cx)*mash),cy_m - round((p1^.y-cy)*mash),s1);
                   end;
      p1:=p1^.Next;
   end;//while
end;//with
end;//DrawMap

function check(s:string; select:integer):boolean;
var
   sh:string;
   i,j:integer;
   Res:boolean;
   Find:Boolean;
 begin
   Res:=False;
if s<>'' then
   case select of
     0:begin
         sh:=#9#13#10;
         j:=1;
         find:=False;
         for i:=1 to StringLen(s) do
           begin
             if s[i]=sh[j] then
               if j=3 then begin
                             j:=1;
                             Find:=True;
                           end
                   else    begin
                             j:=j+1;
                             Find:=True;
                           end;
           end;//for
         if (Find) and (j=1) then Res:=True;
       end;
     1,2:begin
         sh:=#9#9#13#10;
         j:=1;
         find:=False;
         for i:=1 to StringLen(s) do
           begin
             if s[i]=sh[j] then
               if j=4 then begin
                             j:=1;
                             Find:=True;
                           end
                   else    begin
                             j:=j+1;
                             Find:=True;
                           end;
           end;//for
         if (Find) and (j=1) then Res:=True;
       end;
   end;//case
   Check:=Res;
 end;//check()

//==========================================================
procedure TForm1.FormCreate(Sender: TObject);
begin
 i0:=Image2.Width div 2;
 j0:=Image2.Height div 2;
 x0:=0;
 y0:=0;
 Moved:=False;
 clb:=TClipboard.Create;
 mash:=1;
 UpDown1.Position:=50;
 Bneib.Enabled:=False;
 ComboBox1.ItemIndex:=2;
 PageControl1.ActivePageIndex:=0;
 //TrackBar2.Position:=(TrackBar3.Max-TrackBar3.Min) div 2;
end;

procedure TForm1.BloadbuffClick(Sender: TObject);
Var
  s_x,s_y,s_date,s_number:string;
  i,j:integer;
  x,y:real;
  date,number:integer;
  s:ansistring;
  code:integer;
begin
 Clb.Open;
 s:=Clb.AsText;
 DelComma(s);
 if check(s,RGtype.ItemIndex) then
begin
 case RGtype.ItemIndex of
  0: begin
     j:=1;
     i:=1;
     ListBox1.Items.Clear;
     ClearMemory;
     while j<StringLen(s) do
     begin
       s_x:='';
       while (s[j]<>#9) and (j<StringLen(s)) do
         begin
           s_x:=s_x+s[j];
           j:=j+1;
         end;//while
       s_y:='';
       j:=j+1;
       while (s[j]<>#13) and (j<StringLen(s)) do
         begin
           s_y:=s_y+s[j];
           j:=j+1;
         end;//while
       ListBox1.Items.Add(s_x+';'+s_y);
       Val(s_x,x,code);
       Val(s_y,y,code);
       if i=74 then
              AddDot(x,y,i,0,0)
            else
       AddDot(x,y,i,0,0);
       i:=i+1;
       j:=j+2;
     end;//while
     end;//case 0
  1: begin
     j:=1;
     i:=1;
     ListBox1.Items.Clear;
     ClearMemory;
     while j<StringLen(s) do
     begin
       s_number:='';
       while (s[j]<>#9) and (j<StringLen(s)) do
         begin
           s_number:=s_number+s[j];
           j:=j+1;
         end;//while
       j:=j+1;
       s_x:='';
       while (s[j]<>#9) and (j<StringLen(s)) do
         begin
           s_x:=s_x+s[j];
           j:=j+1;
         end;//while
       j:=j+1;
       s_y:='';
       while (s[j]<>#13) and (j<StringLen(s)) do
         begin
           s_y:=s_y+s[j];
           j:=j+1;
         end;//while
       j:=j+2;
       ListBox1.Items.Add('№'+s_number+' '+s_x+';'+s_y);
       Val(s_x,x,code);
       Val(s_y,y,code);
       Val(s_number,number,code);
       AddDot(x,y,i,0,number);
       i:=i+1;

     end;//while
     end;//case 1
  2: begin
     end;//case 2
 end;//case
 Bneib.Enabled:=True;
 StatusBar1.SimpleText:='Подождите, идет обработка данных.';
 Calc;
 DeltaCalc;
 DrawResults(mash);
 StatusBar1.SimpleText:='Данные загружены. Предварительная обработка проведена.';
end
 else
begin
  StatusBar1.Canvas.Font.Color:=ClRed;
  StatusBar1.SimpleText:='';
  StatusBar1.Canvas.TextOut(1,4,'Ошибка данных.');
  If code<>0 then StatusBar1.SimpleText:=StatusBar1.SimpleText+' Неверный чиловой формат.';
  StatusBar1.Canvas.Font.Color:=clBlack;
end;
 Clb.Close;
end;

procedure TForm1.TB1Change(Sender: TObject);
begin
 DrawResults(mash);
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
begin
 ClearMemory;
end;

procedure TForm1.UpDown1Click(Sender: TObject; Button: TUDBtnType);
begin
  if Button=BTnext then
                       begin
                        if mash>0.2 then mash:=mash-0.1;
                       end;
  if Button=BTprev then mash:=mash+0.1;
 DrawResults(mash);
end;

procedure TForm1.Button1Click(Sender: TObject);
begin
 mash:=1;
 DrawResults(-1);
 UpDown1.Position:=50;
end;

procedure TForm1.BneibClick(Sender: TObject);
var
 p1,p2:^nestpoint;
 t:pointer;
 i,j:integer;
 r_av,r_avav:real;
 s1:string;
begin
 PageControl1.ActivePageIndex:=1;
 ListBox2.Clear;
 t:=first_p;
 p1:=t;
 while p1 <> nil do
   begin
     //вычисление R ср. ср.
     t:=first_p;
     p2:=t;
     j:=0;
     r_avav:=0;
     while p2 <> nil do
       begin
         r_av:=0;
         if p1^.N<>p2^.N then
           begin
             for i:=1 to ComboBox1.ItemIndex+1 do
               r_av:=r_av+p2^.rast[i];
             r_av:=r_av/(ComboBox1.ItemIndex+1);
             r_avav:=r_avav+r_av;
             j:=j+1;
           end;
         p2:=p2^.Next;
       end;//while
     r_avav:=r_avav/j;

     str(p1^.N,s1);
     //вывод
     if r_avav<p1^.Rast[1] then
                   begin
                     ListBox2.Items.Add('Гнездо №'+s1+' отброшено.');
                     p1^.Attempted:=False;
                   end
              else begin
                     ListBox2.Items.Add('Гнездо №'+s1+' принято.');
                     p1^.Attempted:=True;
                   end;
     p1:=p1^.Next;
   end;//while
  DrawMapR(-1);
  StatusBar1.SimpleText:='Cоседи отобраны. Нажмите "Вычислить средние расстояния" для продолжения работы.';
end;

procedure TForm1.Button2Click(Sender: TObject);
begin
 ClearMemory;
 ListBox1.Clear;
 Img.Canvas.Brush.Color:=clWhite;
 Img.Canvas.Rectangle(0,0,Img.Width,Img.Height);
 StatusBar1.SimpleText:='Память очищена.';
end;

procedure TForm1.FormShow(Sender: TObject);
begin
 Form1.TabSheet1.TabVisible:=False;
 Form1.TabSheet2.TabVisible:=False;
 Form1.TabSheet3.TabVisible:=False;
 Form1.PageControl1.Enabled:=True;
 Form1.PageControl1.ActivePageIndex:=0;
 StatusBar1.SimpleText:='Система загружена и готова к работе.';
end;

procedure TForm1.Button3Click(Sender: TObject);
begin
 PageControl1.ActivePageIndex:=0;
end;

procedure TForm1.Button4Click(Sender: TObject);
begin
 PageControl1.ActivePageIndex:=2;
 CalcAv;
 DrawMap(1,i0,j0);
 StatusBar1.SimpleText:='Вычисления завершены. Результат сохранен в буфер обмена.';
 StatusBar1.SimpleText :='Изменение масштаба.';
// DrawMap;
end;

procedure TForm1.Button6Click(Sender: TObject);
begin
  PageControl1.ActivePageIndex:=1;
    Form1.Label2.Caption:='';
end;

procedure TForm1.TrackBar2Change(Sender: TObject);
begin
  DrawMapR(0.5+(TrackBar2.max-TrackBar2.Position)/(TrackBar2.max-TrackBar2.min));
  StatusBar1.SimpleText:='Изменение масштаба.';
end;

procedure TForm1.TrackBar3Change(Sender: TObject);
begin
    DrawMap(0.01*(TrackBar3.Position),i0,j0);
    StatusBar1.SimpleText:='Изменение масштаба.';
end;

procedure TForm1.Image2MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  i1:=x;
  j1:=y;
  Moved:=True;
  Image2.Canvas.Pen.Color:=clBlue;
  Image2.Canvas.Rectangle(x-2,y-2,x+2,y+2);
end;

procedure TForm1.Image2MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  i2:=x;
  j2:=y;
  Moved:=False;
  i0:=i0+(i2-i1);
  j0:=j0+(j2-j1);
  DrawMap(0.01*(TrackBar3.Position),i0,j0);
end;

procedure TForm1.Image2MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  if Moved then
    begin
      if (x0<>0) and (y0<>0) then
        begin
          Image2.Canvas.Pen.Color:=clWhite;
          Image2.Canvas.Rectangle(x0-2,y0-2,x0+2,y0+2);
        end;
      Image2.Canvas.Pen.Color:=clBlue;
      Image2.Canvas.Rectangle(x-2,y-2,x+2,y+2);
      x0:=x;
      y0:=y;
    end;

end;

procedure TForm1.RxTrayIcon1Click(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  Form1.DoShow;
end;

end.

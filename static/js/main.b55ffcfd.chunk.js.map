{"version":3,"sources":["utils.js","App.js","index.js"],"names":["parseFloat","string","parsedString","replace","Number","parseString","inputFormat","parts","split","nest","id","nanoid","title","x","y","date","distances","deltaDistances","neighborsCount","r","isAccepted","getSortedDistancesToNeighbors","currentNest","nests","distance","Math","sqrt","pow","push","sort","a","b","getDeltaDistancesToNeighbors","deltas","i","length","maxDelta","max","map","delta","isNestAccepted","firstCount","r_avav","r_av","calculateR","loop_limit","i_max","resultToString","resultStr","App","useState","nestDataText","setNestDataText","nestData","setNestData","setInputFormat","withHeader","setWithHeader","setFirstCount","result","setResult","useEffect","strings","first","utils","className","type","name","checked","onChange","e","target","rows","value","width","height","chartType","loader","data","options","legend","onClick","calculate","href","encodeURIComponent","download","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b55ffcfd.chunk.js","sourcesContent":["import { nanoid } from 'nanoid';\n\nexport const INPUT_FORMAT_COORDINATES = 1;\nexport const INPUT_FORMAT_NUMBER = 2;\nexport const INPUT_FORMAT_DATE = 3;\n\nexport function parseFloat(string) {\n  const parsedString = string.replace(',', '.');\n  return Number.parseFloat(parsedString);\n}\n\nexport function parseString(string, inputFormat) {\n  const parts = string.split(/\\s/);\n  const nest = {\n    id: nanoid(),\n    title: '',\n    x: 0,\n    y: 0,\n    date: null,\n    distances: [],\n    deltaDistances: [],\n    neighborsCount: 0,\n    r: 0,\n    isAccepted: false\n  };\n  switch (inputFormat) {\n    case INPUT_FORMAT_COORDINATES:\n      nest.x = parseFloat(parts[0]);\n      nest.y = parseFloat(parts[1]);\n      break;\n    case INPUT_FORMAT_NUMBER:\n      nest.title = parts[0];\n      nest.x = parseFloat(parts[1]);\n      nest.y = parseFloat(parts[2]);\n      break;\n    case INPUT_FORMAT_DATE:\n      nest.title = parts[0];\n      nest.date = parts[1];\n      nest.x = parseFloat(parts[2]);\n      nest.y = parseFloat(parts[3]);\n      break;\n    default:\n  }\n  return nest;\n}\n\nexport function parseNestData(nestDataText, inputFormat, withHeader) {\n  let result = [];\n  const strings = nestDataText.split(/[\\r\\n]+/);\n  let first = true;\n  for (const string of strings) {\n    if (withHeader && first) {\n      first = false;\n      continue;\n    }\n    if (string === '') continue;\n    result.push(parseString(string, inputFormat));\n  }\n  return result;\n}\n\n/**\n * Метод вычисляет расстояния от текущего гнезда до всез остальных гнёзд\n *\n * @param {Nest} currentNest текущее гнездо\n * @param {Nest[]} nests все гнёзда\n * @returns {[number]}\n */\nexport function getSortedDistancesToNeighbors(currentNest, nests) {\n  /*\n    procedure Calc_date(list_in: TList);\n    var\n      i, j, k: integer;\n      L: TList;\n      Rast: real;\n      p1, p2: ^nestpoint;\n      temp_d, temp1_d: ^dot;\n      changed: boolean;\n      p_real: ^real;\n    begin\n      L := TList.Create;\n      for i := 0 to (List_in.Count - 1) do\n      begin\n        //заполняем список\n        for j := 0 to (List_in.Count - 1) do\n        begin\n          if (i <> j) then\n          begin\n            p1 := List_in.Items[i];\n            p2 := List_in.Items[j];\n            //деление на 2, т.к. необходима ПОЛОВИНА расстояний (confirmed by Alexey)\n            rast := (sqrt(sqr(p1^.x - p2^.x) + sqr(p1^.y - p2^.y))) / 2;\n            new(temp_d);\n            temp_d^.N := p2^.N;\n            temp_d^.R := rast;\n            L.Add(temp_d);\n            temp_d := nil;\n          end;//if\n        end;//for\n        //cортировка\n        changed := True;\n        while changed do\n        begin\n          changed := False;\n          for k := 0 to (L.Count - 2) do\n          begin\n            temp_d := L.Items[k];\n            temp1_d := L.Items[k + 1];\n            if temp1_d^.R < temp_d^.R then\n            begin\n              L.Exchange(k, k + 1);\n              Changed := True;\n            end;\n          end;//for\n        end;//while\n        //закидываем всё в Rast[]\n        p1 := List_in.Items[i];\n        p1^.Rast.Clear;\n        for k := 0 to (L.Count - 1) do\n        begin\n          temp_d := L.Items[k];\n          New(p_real);\n          p_real^ := temp_d^.R;\n          p1^.Rast.Add(p_real);\n        end;\n        L.Clear;\n      end;\n    end;// Calc_date;\n   */\n  const distances = [];\n  for (const nest of nests) {\n    if (nest.id === currentNest.id) continue;\n    const distance =\n      Math.sqrt(Math.pow(nest.x - currentNest.x, 2) + Math.pow(nest.y - currentNest.y, 2)) / 2;\n    distances.push(distance);\n  }\n  distances.sort((a, b) => a - b);\n  return distances;\n}\n\n/**\n * Метод вычисляет дельту между расстояниями для конкретного гнезда\n * Своего рода производная по расстояниям\n *\n * @param {number[]} distances\n * @returns {number[]}\n */\nexport function getDeltaDistancesToNeighbors(distances) {\n  /*\n    procedure DeltaCalc_date(list_in: TList);\n    var\n      p1: ^nestpoint;\n      max: real;\n      i, k: integer;\n      p_real_1, p_real_2, p_real_3: ^real;\n    begin\n      for k := 0 to (list_in.Count - 1) do\n      begin\n        p1 := list_in.Items[k];\n        //вычисление дельты\n        p1^.Delta_Rast.Clear;\n        for i := 0 to p1^.Rast.Count - 2 do\n        begin\n          p_real_1 := p1^.Rast.Items[i + 1];\n          p_real_2 := p1^.Rast.Items[i];\n          New(p_real_3);\n          p_real_3^ := p_real_1^ - p_real_2^;\n          p1^.Delta_Rast.Add(p_real_3);\n        end;\n        //поиск максимальной\n        max := 0;\n        for i := 0 to p1^.Delta_Rast.Count - 1 do\n        begin\n          p_real_1 := p1^.Delta_Rast.Items[i];\n          if p_real_1^ > max then\n            max := p_real_1^;\n        end;\n        //нормализация\n        if max > 0 then\n          for i := 0 to p1^.Delta_Rast.Count - 1 do\n          begin\n            p_real_1 := p1^.Delta_Rast.Items[i];\n            p_real_1^ := p_real_1^ / max;\n          end;\n      end;//for\n    end;// DeltaCalc_date;\n   */\n  const deltas = [];\n  for (let i = 0; i < distances.length - 1; i++) {\n    deltas.push(distances[i + 1] - distances[i]);\n  }\n  const maxDelta = Math.max(...deltas);\n  return deltas.map(delta => delta / maxDelta);\n}\n\n/**\n * Метод определяет, рассчитывать ли среднее расстояние до ближайших гнёзд для\n * этого конкретного гнезда.\n *\n * Вначале мы считаем среднее расстояние до firstCount ближайших соседей для\n * каждого гнезда, кроме текущего. Это r_av.\n *\n * Потом мы считаем среднее этих средних расстояний r_avav.\n *\n * Если расстояние до ПЕРВОГО соседа у текущего гнезда больше или равно r_avav,\n * то гнездо участвует в дальнейшем расчёте. Т.е. гнездо не одиночное, у него\n * есть соседи.\n *\n * @param {Nest} currentNest\n * @param {Nest[]} nests\n * @param {number} firstCount\n * @returns {boolean}\n */\nexport function isNestAccepted(currentNest, nests, firstCount) {\n  /*\n    procedure SelectNeibs(List_in: TList);\n    var\n      p1, p2: ^nestpoint;\n      i, j, k, Count: integer;\n      r_av, r_avav: real;\n      p_real: ^real;\n    begin\n      for i := 0 to (List_in.Count - 1) do\n      begin\n        //вычисление R ср. ср.\n        Count := 0;\n        r_avav := 0;\n        for j := 0 to (List_in.Count - 1) do\n        begin\n          r_av := 0;\n          p1 := List_in.Items[i];\n          p2 := List_in.Items[j];\n          if p1^.N <> p2^.N then\n          begin\n            for k := 1 to (Form1.ComboBox1.ItemIndex + 1) do\n            begin\n              if (k - 1) < p2^.rast.Count then\n              begin\n                p_real := p2^.rast.Items[k - 1];\n                r_av := r_av + p_real^;\n              end;\n            end;\n            r_av := r_av / (form1.ComboBox1.ItemIndex + 1);\n            r_avav := r_avav + r_av;\n            Count := Count + 1;\n          end;\n        end;//while\n        r_avav := r_avav / Count;\n        //вывод\n        p_real := p1^.Rast.Items[0];\n        if r_avav < p_real^ then\n        begin\n          p1^.Attempted := False;\n        end\n        else\n        begin\n          p1^.Attempted := True;\n        end;\n      end;//for\n    end;//selectNeibs\n   */\n  let r_avav = 0;\n  for (const nest of nests) {\n    let r_av = 0;\n    if (nest.id === currentNest.id) continue;\n\n    for (let i = 0; i < firstCount; i++) {\n      r_av += nest.distances[i];\n    }\n\n    r_av = r_av / firstCount;\n    r_avav += r_av;\n  }\n  r_avav = r_avav / (nests.length - 1);\n  return r_avav >= currentNest.distances[0];\n}\n\n/**\n * Ключевая функция расчёта среднего расстояния до соседей.\n * 1. Определяем, скольких ближайших соседей анализировать (6 или сколько есть).\n * 2. Находим среди них максимальную дельту расстояний. Считаем, что этот пик\n * на графике ограничивает зону \"настоящих\" соседей.\n * 3. Для этой дельты находим номер соседа.\n * 4. Чисто соседей: номер соседа + 1.\n * 5. Среднее расстояние: сумма расстояний до соседей / число соседей.\n *\n * @param {Nest} nest\n * @returns {{r: number, neighborsCount: number}}\n */\nexport function calculateR(nest) {\n  /*\n      max := 0;\n      i_max := 1;\n      if p1^.Delta_Rast.Count > 6 then\n        loop_limit := 5 //6 neibors\n      else\n        loop_limit := p1^.Delta_Rast.Count - 1; //if less than 6\n      for i := 1 to loop_limit do\n      begin\n        p_real := p1^.Delta_Rast.Items[i];\n        if (p_real^ > max) then\n        begin\n          max := p_real^;\n          i_max := i;\n        end;//if\n      end;\n      r := 0;\n      for i := 0 to i_max do\n      begin\n        p_real := p1^.Rast.Items[i];\n        r := r + p_real^;\n      end;\n      r := r / (i_max + 1);\n      p1^.R_av := r;\n      Set_R_and_Date(p1^.N, r, day);\n      p1^.Neib_Count := i_max + 1;\n   */\n  let maxDelta = 0;\n  let i_max = 0;\n  let loop_limit;\n  let r = 0;\n\n  if (nest.deltaDistances.length > 6) {\n    loop_limit = 5; //6 neibors\n  } else {\n    loop_limit = nest.deltaDistances.length - 1; //if less than 6\n  }\n\n  for (let i = 1; i <= loop_limit; i++) {\n    if (nest.deltaDistances[i] > maxDelta) {\n      maxDelta = nest.deltaDistances[i];\n      i_max = i;\n    }\n  }\n\n  for (let i = 0; i <= i_max; i++) {\n    r += nest.distances[i];\n  }\n  r = r / (i_max + 1);\n  return { r, neighborsCount: i_max + 1 };\n}\n\nexport function resultToString(nests) {\n  let resultStr = 'Number\\tR\\tNeib\\n';\n  for (const nest of nests) {\n    resultStr += `${nest.title ? nest.title : nest.id}\\t`;\n    if (nest.isAccepted) {\n      resultStr += `${nest.r}\\t${nest.neighborsCount}`;\n    } else {\n      resultStr += `NAN\\t0`;\n    }\n    resultStr += `\\n`;\n  }\n  return resultStr;\n}\n","import React, { useState, useEffect } from 'react';\nimport { Chart } from 'react-google-charts';\nimport * as utils from './utils';\nimport './App.css';\n\nfunction App() {\n  const [nestDataText, setNestDataText] = useState('');\n  const [nestData, setNestData] = useState([]);\n  const [inputFormat, setInputFormat] = useState(utils.INPUT_FORMAT_NUMBER);\n  const [withHeader, setWithHeader] = useState(false);\n  const [firstCount, setFirstCount] = useState(3);\n  const [result, setResult] = useState([]);\n\n  useEffect(() => {\n    setNestData(utils.parseNestData(nestDataText, inputFormat, withHeader));\n  }, [nestDataText, inputFormat, withHeader]);\n\n  function calculate() {\n    for (const currentNest of nestData) {\n      const distances = utils.getSortedDistancesToNeighbors(currentNest, nestData);\n      const deltaDistances = utils.getDeltaDistancesToNeighbors(distances);\n      currentNest.distances = distances;\n      currentNest.deltaDistances = deltaDistances;\n    }\n\n    for (const currentNest of nestData) {\n      currentNest.isAccepted = utils.isNestAccepted(currentNest, nestData, firstCount);\n      if (currentNest.isAccepted) {\n        const { r, neighborsCount } = utils.calculateR(currentNest);\n        currentNest.r = r;\n        currentNest.neighborsCount = neighborsCount;\n      }\n    }\n\n    setResult([...nestData]);\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"wrapper\">\n        <h1>Nest</h1>\n        <h4>Выберите формат входных данных:</h4>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"inputFormat\"\n              checked={inputFormat === utils.INPUT_FORMAT_COORDINATES}\n              onChange={e => e.target.checked && setInputFormat(utils.INPUT_FORMAT_COORDINATES)}\n            />\n            X Y\n          </label>\n        </div>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"inputFormat\"\n              checked={inputFormat === utils.INPUT_FORMAT_NUMBER}\n              onChange={e => e.target.checked && setInputFormat(utils.INPUT_FORMAT_NUMBER)}\n            />\n            &lt;Метка гнезда&gt; X Y\n          </label>\n        </div>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"inputFormat\"\n              checked={inputFormat === utils.INPUT_FORMAT_DATE}\n              onChange={e => e.target.checked && setInputFormat(utils.INPUT_FORMAT_DATE)}\n            />\n            &lt;Метка гнезда&gt; &lt;Дата основания&gt; X Y\n          </label>\n        </div>\n        <div>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={withHeader}\n              onChange={e => setWithHeader(e.target.checked)}\n            />\n            С заголовком\n          </label>\n        </div>\n        <div>\n          <h4>Скопируйте сюда координаты гнёзд:</h4>\n          <textarea\n            rows={5}\n            className=\"textarea-with-data\"\n            value={nestDataText}\n            onChange={e => setNestDataText(e.target.value)}\n          />\n        </div>\n        <div>\n          <label>\n            Брать первых\n            <select value={firstCount} onChange={e => setFirstCount(e.target.value)}>\n              <option>1</option>\n              <option>2</option>\n              <option>3</option>\n              <option>4</option>\n              <option>5</option>\n              <option>6</option>\n              <option>7</option>\n            </select>\n          </label>\n        </div>\n        <div>\n          <h4>Гнёзда:</h4>\n          <ul className=\"nest-list\">\n            {nestData.map(nest => (\n              // eslint-disable-next-line react/jsx-key\n              <li>\n                <b>{nest.title ? nest.title : nest.id}</b>&nbsp;\n                {nest.date && nest.date}&nbsp;\n                {nest.x} {nest.y}\n              </li>\n            ))}\n          </ul>\n          <Chart\n            width={'600px'}\n            height={'400px'}\n            chartType=\"ScatterChart\"\n            loader={<div>Loading Chart</div>}\n            data={[['x', 'y'], ...nestData.map(nest => [nest.x, nest.y])]}\n            options={{\n              legend: 'none'\n            }}\n          />\n        </div>\n        <div>\n          <button onClick={() => calculate()}>Расчитать!</button>\n        </div>\n        <div>\n          <h4>Результат</h4>\n          <p>\n            Можно скопировать или{' '}\n            <a\n              href={`data:text/plain;charset=UTF-8,${encodeURIComponent(\n                utils.resultToString(result)\n              )}`}\n              download=\"nest_results.txt\"\n            >\n              скачать в виде файла\n            </a>\n          </p>\n          <textarea className=\"textarea-with-data\" rows={5} value={utils.resultToString(result)} />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}
{"version":3,"sources":["utils.js","App.js","index.js"],"names":["parseFloat","string","parsedString","replace","Number","parseString","inputFormat","parts","split","nest","id","nanoid","title","x","y","date","distances","deltaDistances","neighborsCount","r","isAccepted","getSortedDistancesToNeighbors","currentNest","nests","distance","Math","sqrt","pow","push","sort","a","b","getDeltaDistancesToNeighbors","deltas","i","length","maxDelta","max","map","delta","isNestAccepted","firstCount","r_avav","r_av","calculateR","loop_limit","i_max","resultToString","resultStr","toFixed","App","useState","nestDataText","setNestDataText","nestData","setNestData","setInputFormat","withHeader","setWithHeader","setFirstCount","selectedNest","setSelectedNest","anyChartDistances","anychart","line","anyChartMap","bubble","minBubbleSize","maxBubbleSize","useEffect","result","strings","first","utils","console","log","chartData","dataSet","data","set","seriesData_1","mapAs","value","seriesData_2","setDistancesGraphData","accepted","notAccepted","setMapGraphData","className","type","name","checked","onChange","e","target","rows","min","onClick","instance","height","calculate","href","encodeURIComponent","download","readOnly","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.04d8003a.chunk.js","sourcesContent":["import { nanoid } from 'nanoid';\n\nexport const INPUT_FORMAT_COORDINATES = 1;\nexport const INPUT_FORMAT_NUMBER = 2;\nexport const INPUT_FORMAT_DATE = 3;\n\nexport function parseFloat(string) {\n  const parsedString = string.replace(',', '.');\n  return Number.parseFloat(parsedString);\n}\n\nexport function parseString(string, inputFormat) {\n  const parts = string.split(/\\s/);\n  const nest = {\n    id: nanoid(),\n    title: '',\n    x: 0,\n    y: 0,\n    date: null,\n    distances: [],\n    deltaDistances: [],\n    neighborsCount: 0,\n    r: 0,\n    isAccepted: false\n  };\n  switch (inputFormat) {\n    case INPUT_FORMAT_COORDINATES:\n      nest.x = parseFloat(parts[0]);\n      nest.y = parseFloat(parts[1]);\n      break;\n    case INPUT_FORMAT_NUMBER:\n      nest.title = parts[0];\n      nest.x = parseFloat(parts[1]);\n      nest.y = parseFloat(parts[2]);\n      break;\n    case INPUT_FORMAT_DATE:\n      nest.title = parts[0];\n      nest.date = parts[1];\n      nest.x = parseFloat(parts[2]);\n      nest.y = parseFloat(parts[3]);\n      break;\n    default:\n  }\n  return nest;\n}\n\nexport function parseNestData(nestDataText, inputFormat, withHeader) {\n  let result = [];\n  const strings = nestDataText.split(/[\\r\\n]+/);\n  let first = true;\n  for (const string of strings) {\n    if (withHeader && first) {\n      first = false;\n      continue;\n    }\n    if (string === '') continue;\n    result.push(parseString(string, inputFormat));\n  }\n  return result;\n}\n\n/**\n * Метод вычисляет расстояния от текущего гнезда до всез остальных гнёзд\n *\n * @param {Nest} currentNest текущее гнездо\n * @param {Nest[]} nests все гнёзда\n * @returns {[number]}\n */\nexport function getSortedDistancesToNeighbors(currentNest, nests) {\n  /*\n    procedure Calc_date(list_in: TList);\n    var\n      i, j, k: integer;\n      L: TList;\n      Rast: real;\n      p1, p2: ^nestpoint;\n      temp_d, temp1_d: ^dot;\n      changed: boolean;\n      p_real: ^real;\n    begin\n      L := TList.Create;\n      for i := 0 to (List_in.Count - 1) do\n      begin\n        //заполняем список\n        for j := 0 to (List_in.Count - 1) do\n        begin\n          if (i <> j) then\n          begin\n            p1 := List_in.Items[i];\n            p2 := List_in.Items[j];\n            //деление на 2, т.к. необходима ПОЛОВИНА расстояний (confirmed by Alexey)\n            rast := (sqrt(sqr(p1^.x - p2^.x) + sqr(p1^.y - p2^.y))) / 2;\n            new(temp_d);\n            temp_d^.N := p2^.N;\n            temp_d^.R := rast;\n            L.Add(temp_d);\n            temp_d := nil;\n          end;//if\n        end;//for\n        //cортировка\n        changed := True;\n        while changed do\n        begin\n          changed := False;\n          for k := 0 to (L.Count - 2) do\n          begin\n            temp_d := L.Items[k];\n            temp1_d := L.Items[k + 1];\n            if temp1_d^.R < temp_d^.R then\n            begin\n              L.Exchange(k, k + 1);\n              Changed := True;\n            end;\n          end;//for\n        end;//while\n        //закидываем всё в Rast[]\n        p1 := List_in.Items[i];\n        p1^.Rast.Clear;\n        for k := 0 to (L.Count - 1) do\n        begin\n          temp_d := L.Items[k];\n          New(p_real);\n          p_real^ := temp_d^.R;\n          p1^.Rast.Add(p_real);\n        end;\n        L.Clear;\n      end;\n    end;// Calc_date;\n   */\n  const distances = [];\n  for (const nest of nests) {\n    if (nest.id === currentNest.id) continue;\n    const distance =\n      Math.sqrt(Math.pow(nest.x - currentNest.x, 2) + Math.pow(nest.y - currentNest.y, 2)) / 2;\n    distances.push(distance);\n  }\n  distances.sort((a, b) => a - b);\n  return distances;\n}\n\n/**\n * Метод вычисляет дельту между расстояниями для конкретного гнезда\n * Своего рода производная по расстояниям\n *\n * @param {number[]} distances\n * @returns {number[]}\n */\nexport function getDeltaDistancesToNeighbors(distances) {\n  /*\n    procedure DeltaCalc_date(list_in: TList);\n    var\n      p1: ^nestpoint;\n      max: real;\n      i, k: integer;\n      p_real_1, p_real_2, p_real_3: ^real;\n    begin\n      for k := 0 to (list_in.Count - 1) do\n      begin\n        p1 := list_in.Items[k];\n        //вычисление дельты\n        p1^.Delta_Rast.Clear;\n        for i := 0 to p1^.Rast.Count - 2 do\n        begin\n          p_real_1 := p1^.Rast.Items[i + 1];\n          p_real_2 := p1^.Rast.Items[i];\n          New(p_real_3);\n          p_real_3^ := p_real_1^ - p_real_2^;\n          p1^.Delta_Rast.Add(p_real_3);\n        end;\n        //поиск максимальной\n        max := 0;\n        for i := 0 to p1^.Delta_Rast.Count - 1 do\n        begin\n          p_real_1 := p1^.Delta_Rast.Items[i];\n          if p_real_1^ > max then\n            max := p_real_1^;\n        end;\n        //нормализация\n        if max > 0 then\n          for i := 0 to p1^.Delta_Rast.Count - 1 do\n          begin\n            p_real_1 := p1^.Delta_Rast.Items[i];\n            p_real_1^ := p_real_1^ / max;\n          end;\n      end;//for\n    end;// DeltaCalc_date;\n   */\n  const deltas = [];\n  for (let i = 0; i < distances.length - 1; i++) {\n    deltas.push(distances[i + 1] - distances[i]);\n  }\n  const maxDelta = Math.max(...deltas);\n  return deltas.map(delta => delta / maxDelta);\n}\n\n/**\n * Метод определяет, рассчитывать ли среднее расстояние до ближайших гнёзд для\n * этого конкретного гнезда.\n *\n * Вначале мы считаем среднее расстояние до firstCount ближайших соседей для\n * каждого гнезда, кроме текущего. Это r_av.\n *\n * Потом мы считаем среднее этих средних расстояний r_avav.\n *\n * Если расстояние до ПЕРВОГО соседа у текущего гнезда больше или равно r_avav,\n * то гнездо участвует в дальнейшем расчёте. Т.е. гнездо не одиночное, у него\n * есть соседи.\n *\n * @param {Nest} currentNest\n * @param {Nest[]} nests\n * @param {number} firstCount\n * @returns {boolean}\n */\nexport function isNestAccepted(currentNest, nests, firstCount) {\n  /*\n    procedure SelectNeibs(List_in: TList);\n    var\n      p1, p2: ^nestpoint;\n      i, j, k, Count: integer;\n      r_av, r_avav: real;\n      p_real: ^real;\n    begin\n      for i := 0 to (List_in.Count - 1) do\n      begin\n        //вычисление R ср. ср.\n        Count := 0;\n        r_avav := 0;\n        for j := 0 to (List_in.Count - 1) do\n        begin\n          r_av := 0;\n          p1 := List_in.Items[i];\n          p2 := List_in.Items[j];\n          if p1^.N <> p2^.N then\n          begin\n            for k := 1 to (Form1.ComboBox1.ItemIndex + 1) do\n            begin\n              if (k - 1) < p2^.rast.Count then\n              begin\n                p_real := p2^.rast.Items[k - 1];\n                r_av := r_av + p_real^;\n              end;\n            end;\n            r_av := r_av / (form1.ComboBox1.ItemIndex + 1);\n            r_avav := r_avav + r_av;\n            Count := Count + 1;\n          end;\n        end;//while\n        r_avav := r_avav / Count;\n        //вывод\n        p_real := p1^.Rast.Items[0];\n        if r_avav < p_real^ then\n        begin\n          p1^.Attempted := False;\n        end\n        else\n        begin\n          p1^.Attempted := True;\n        end;\n      end;//for\n    end;//selectNeibs\n   */\n  let r_avav = 0;\n  for (const nest of nests) {\n    let r_av = 0;\n    if (nest.id === currentNest.id) continue;\n\n    for (let i = 0; i < firstCount; i++) {\n      r_av += nest.distances[i];\n    }\n\n    r_av = r_av / firstCount;\n    r_avav += r_av;\n  }\n  r_avav = r_avav / (nests.length - 1);\n  return r_avav >= currentNest.distances[0];\n}\n\n/**\n * Ключевая функция расчёта среднего расстояния до соседей.\n * 1. Определяем, скольких ближайших соседей анализировать (6 или сколько есть).\n * 2. Находим среди них максимальную дельту расстояний. Считаем, что этот пик\n * на графике ограничивает зону \"настоящих\" соседей.\n * 3. Для этой дельты находим номер соседа.\n * 4. Чисто соседей: номер соседа + 1.\n * 5. Среднее расстояние: сумма расстояний до соседей / число соседей.\n *\n * @param {Nest} nest\n * @returns {{r: number, neighborsCount: number}}\n */\nexport function calculateR(nest) {\n  /*\n      max := 0;\n      i_max := 1;\n      if p1^.Delta_Rast.Count > 6 then\n        loop_limit := 5 //6 neibors\n      else\n        loop_limit := p1^.Delta_Rast.Count - 1; //if less than 6\n      for i := 1 to loop_limit do\n      begin\n        p_real := p1^.Delta_Rast.Items[i];\n        if (p_real^ > max) then\n        begin\n          max := p_real^;\n          i_max := i;\n        end;//if\n      end;\n      r := 0;\n      for i := 0 to i_max do\n      begin\n        p_real := p1^.Rast.Items[i];\n        r := r + p_real^;\n      end;\n      r := r / (i_max + 1);\n      p1^.R_av := r;\n      Set_R_and_Date(p1^.N, r, day);\n      p1^.Neib_Count := i_max + 1;\n   */\n  let maxDelta = 0;\n  let i_max = 0;\n  let loop_limit;\n  let r = 0;\n\n  if (nest.deltaDistances.length > 6) {\n    loop_limit = 5; //6 neibors\n  } else {\n    loop_limit = nest.deltaDistances.length - 1; //if less than 6\n  }\n\n  for (let i = 1; i <= loop_limit; i++) {\n    if (nest.deltaDistances[i] > maxDelta) {\n      maxDelta = nest.deltaDistances[i];\n      i_max = i;\n    }\n  }\n\n  for (let i = 0; i <= i_max; i++) {\n    r += nest.distances[i];\n  }\n  r = r / (i_max + 1);\n  return { r, neighborsCount: i_max + 1 };\n}\n\nexport function resultToString(nests) {\n  let resultStr = 'Number\\tR\\tNeib\\n';\n  for (const nest of nests) {\n    resultStr += `${nest.title ? nest.title : nest.id}\\t`;\n    if (nest.isAccepted) {\n      resultStr += `${nest.r.toFixed(3)}\\t${nest.neighborsCount}`;\n    } else {\n      resultStr += `NAN\\t0`;\n    }\n    resultStr += `\\n`;\n  }\n  return resultStr;\n}\n","import React, { useState, useEffect } from 'react';\nimport AnyChart from 'anychart-react';\nimport anychart from 'anychart';\nimport * as utils from './utils';\nimport './App.css';\n\nfunction App() {\n  const [nestDataText, setNestDataText] = useState('');\n  const [nestData, setNestData] = useState([]);\n  const [inputFormat, setInputFormat] = useState(utils.INPUT_FORMAT_NUMBER);\n  const [withHeader, setWithHeader] = useState(true);\n  const [firstCount, setFirstCount] = useState(3);\n  const [selectedNest, setSelectedNest] = useState(0);\n\n  const anyChartDistances = anychart.line();\n  const anyChartMap = anychart.bubble();\n  anyChartMap.minBubbleSize('0.5%');\n  anyChartMap.maxBubbleSize('5%');\n\n  useEffect(() => {\n    const nestData = utils.parseNestData(nestDataText, inputFormat, withHeader);\n    for (const currentNest of nestData) {\n      const distances = utils.getSortedDistancesToNeighbors(currentNest, nestData);\n      const deltaDistances = utils.getDeltaDistancesToNeighbors(distances);\n      currentNest.distances = distances;\n      currentNest.deltaDistances = deltaDistances;\n    }\n    setNestData(nestData);\n  }, [nestDataText, inputFormat, withHeader]);\n\n  useEffect(() => {\n    setDistancesGraphData(selectedNest);\n  }, [nestData, selectedNest]);\n\n  useEffect(() => {\n    setMapGraphData(nestData);\n  }, [nestData]);\n\n  function calculate() {\n    for (const currentNest of nestData) {\n      currentNest.isAccepted = utils.isNestAccepted(currentNest, nestData, firstCount);\n      if (currentNest.isAccepted) {\n        const { r, neighborsCount } = utils.calculateR(currentNest);\n        currentNest.r = r;\n        currentNest.neighborsCount = neighborsCount;\n      }\n    }\n\n    setNestData([...nestData]);\n  }\n\n  function setDistancesGraphData(selectedNest) {\n    console.log('setDistancesGraphData', anyChartDistances);\n    if (!nestData[selectedNest]) return;\n\n    const chartData = [];\n    for (let i = 0; i < nestData[selectedNest].distances.length; i++) {\n      chartData.push([\n        i,\n        nestData[selectedNest].distances[i],\n        nestData[selectedNest].deltaDistances[i]\n      ]);\n    }\n    const dataSet = anychart.data.set(chartData);\n    const seriesData_1 = dataSet.mapAs({ x: 0, value: 1 });\n    const seriesData_2 = dataSet.mapAs({ x: 0, value: 2 });\n    anyChartDistances.line(seriesData_1);\n    anyChartDistances.line(seriesData_2);\n  }\n\n  function setMapGraphData(nests) {\n    if (!nests || !nests.length) return;\n\n    const accepted = [],\n      notAccepted = [];\n    for (const nest of nests) {\n      if (nest.isAccepted) {\n        accepted.push([nest.x, nest.y, nest.r]);\n      } else {\n        notAccepted.push([nest.x, nest.y, 0]);\n      }\n    }\n    anyChartMap.bubble(accepted);\n    anyChartMap.bubble(notAccepted);\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"wrapper\">\n        <h1>Nest</h1>\n        <h4>Выберите формат входных данных:</h4>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"inputFormat\"\n              checked={inputFormat === utils.INPUT_FORMAT_COORDINATES}\n              onChange={e => e.target.checked && setInputFormat(utils.INPUT_FORMAT_COORDINATES)}\n            />\n            X Y\n          </label>\n        </div>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"inputFormat\"\n              checked={inputFormat === utils.INPUT_FORMAT_NUMBER}\n              onChange={e => e.target.checked && setInputFormat(utils.INPUT_FORMAT_NUMBER)}\n            />\n            &lt;Метка гнезда&gt; X Y\n          </label>\n        </div>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"inputFormat\"\n              checked={inputFormat === utils.INPUT_FORMAT_DATE}\n              onChange={e => e.target.checked && setInputFormat(utils.INPUT_FORMAT_DATE)}\n            />\n            &lt;Метка гнезда&gt; &lt;Дата основания&gt; X Y\n          </label>\n        </div>\n        <div>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={withHeader}\n              onChange={e => setWithHeader(e.target.checked)}\n            />\n            С заголовком\n          </label>\n        </div>\n        <div>\n          <h4>Скопируйте сюда координаты гнёзд:</h4>\n          <div className=\"input-coordinates-block\">\n            <div className=\"input-textarea\">\n              <textarea\n                rows={10}\n                className=\"textarea-with-data\"\n                value={nestDataText}\n                onChange={e => setNestDataText(e.target.value)}\n              />\n            </div>\n            <div className=\"nest-list\">\n              <ul>\n                {nestData.map(nest => (\n                  <li key={nest.id}>\n                    <b>{nest.title ? nest.title : nest.id}</b>&nbsp;\n                    {nest.date && nest.date}&nbsp;\n                    {nest.x} {nest.y}\n                  </li>\n                ))}\n              </ul>\n            </div>\n          </div>\n        </div>\n        <div>\n          <label>\n            Брать первых\n            <select value={firstCount} onChange={e => setFirstCount(e.target.value)}>\n              <option>1</option>\n              <option>2</option>\n              <option>3</option>\n              <option>4</option>\n              <option>5</option>\n              <option>6</option>\n              <option>7</option>\n            </select>\n          </label>\n        </div>\n        <div className=\"distances\">\n          <h4>Расстояния до соседей:</h4>\n          <input\n            type=\"range\"\n            min=\"0\"\n            max={nestData.length - 1}\n            value={selectedNest}\n            onChange={e => setSelectedNest(e.target.value)}\n          />\n          <button onClick={() => selectedNest > 0 && setSelectedNest(selectedNest - 1)}>\n            &lt;\n          </button>\n          <button\n            onClick={() => selectedNest < nestData.length - 1 && setSelectedNest(selectedNest + 1)}\n          >\n            &gt;\n          </button>\n          <AnyChart\n            id=\"distances\"\n            title={`Расстояния до соседей гнезда ${nestData[selectedNest]?.title}`}\n            instance={anyChartDistances}\n            height={600}\n          />\n        </div>\n        <div>\n          <button onClick={() => calculate()}>Расчитать!</button>\n        </div>\n        <div>\n          <h4>Результат</h4>\n          <p>\n            Можно скопировать или{' '}\n            <a\n              href={`data:text/plain;charset=UTF-8,${encodeURIComponent(\n                utils.resultToString(nestData).replace('\\n', '\\r\\n')\n              )}`}\n              download=\"nest_results.txt\"\n            >\n              скачать в виде файла\n            </a>\n          </p>\n          <div className=\"results-block\">\n            <div className=\"results-textarea\">\n              <textarea\n                className=\"textarea-with-data\"\n                rows={5}\n                value={utils.resultToString(nestData)}\n                readOnly\n              />\n            </div>\n            <div className=\"results-graph\">\n              <AnyChart id=\"nest-map\" instance={anyChartMap} title=\"Карта гнёзд\" height={600} />\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}